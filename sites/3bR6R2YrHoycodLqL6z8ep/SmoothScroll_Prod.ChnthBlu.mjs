import { t as e } from "./rolldown-runtime.DYJfJqco.mjs"; import { F as t, L as n, M as r, N as i, O as a, S as o, T as s, _ as c, c as l, d as u, g as d, j as f, k as p, l as m, u as h, v as g, w as _, z as v } from "./react.XYFExCw3.mjs"; import { C as y, F as b, J as x, K as S, R as ee, f as te, g as C, j as ne, r as re, s as w, t as T, w as E, z as ie } from "./motion.Cj-3pPg7.mjs"; import { E as D, K as O, _t as k, i as A, y as j } from "./framer.DHnVnQh0.mjs"; import { i as M, r as ae } from "./KHQgVYK_f.f1h3Iva6.mjs"; import { a as oe, c as se, d as ce, g as le, h as N, i as ue, l as de, m as fe, n as P, p as F, r as I, t as L, u as R, v as pe } from "./OIjZRBmWDcIE2B6qgG1j.CYzkjwU7.mjs"; function me() { if (!he()) return; let [e, n] = t(!document.hidden); return i(() => { let e = () => n(!document.hidden); return document.addEventListener(`visibilitychange`, e, !1), () => { document.removeEventListener(`visibilitychange`, e) } }, []), e } var he, ge = e((() => { _(), he = () => typeof document == `object` })); function z(e, t) { let n, r = e.current; return Object.defineProperty(e, `current`, { get() { return r }, set(e) { if (r = e, e === null) { t.abort(); return } n?.(e) }, configurable: !0 }), r || new Promise((e, r) => { n = e, t.signal.addEventListener(`abort`, r) }).catch(() => { }) } function B(e) { let { slots: n = [], startFrom: c, direction: l, effectsOptions: d, autoPlayControl: p, dragControl: m, alignment: _, gap: y, padding: ne, paddingPerSide: re, paddingTop: w, paddingRight: T, paddingBottom: ie, paddingLeft: D, itemAmount: O, fadeOptions: k, intervalControl: A, transitionControl: ae, arrowOptions: oe, borderRadius: se, progressOptions: ce, style: le } = e, { effectsOpacity: N, effectsScale: ue, effectsRotate: de, effectsPerspective: fe, effectsHover: P, playOffscreen: F } = d, { fadeContent: I, overflow: L, fadeWidth: R, fadeInset: pe, fadeAlpha: he } = k, { showMouseControls: ge, arrowSize: B, arrowRadius: ke, arrowFill: Ae, leftArrow: je, rightArrow: Me, arrowShouldSpace: Ne = !0, arrowShouldFadeIn: Pe = !1, arrowPosition: H, arrowPadding: U, arrowGap: Fe, arrowPaddingTop: Ie, arrowPaddingRight: Le, arrowPaddingBottom: Re, arrowPaddingLeft: ze } = oe, { showProgressDots: Be, dotSize: Ve, dotsInset: He, dotsRadius: Ue, dotsPadding: We, dotsGap: W, dotsFill: Ge, dotsBackground: Ke, dotsActiveOpacity: qe, dotsOpacity: Je, dotsBlur: Ye } = ce, Xe = re ? `${w}px ${T}px ${ie}px ${D}px` : `${ne}px`, G = j.current() === j.canvas, K = n.filter(Boolean), q = s.count(K), Ze = q > 0, J = l === `left` || l === `right`, Y = l === `right` || l === `bottom`; if (!Ze) return u(`section`, { style: V, children: [h(`div`, { style: ye, children: `â­ï¸` }), h(`p`, { style: be, children: `Connect to Content` }), h(`p`, { style: xe, children: `Add layers or components to make infinite auto-playing slideshows.` })] }); let X = a(null), Qe = f(() => [{ current: null }, { current: null }], [K]), $e = a(void 0), [Z, et] = t({ parent: null, children: null, item: null, itemWidth: null, itemHeight: null, viewportLength: null }), [tt, nt] = t(!1), [rt, it] = t(p), [at, ot] = t(!1), [Q, st] = t(!1), ct = [], lt = 4; G && (lt = 1); let ut = r(() => { if (!X.current) return; let e = Qe[0].current, t = Qe[1].current, n = J ? X.current.offsetWidth : X.current.offsetHeight, r = e ? J ? e.offsetLeft : e.offsetTop : 0; et({ parent: n, children: (t ? J ? t.offsetLeft + t.offsetWidth : t.offsetTop + t.offsetHeight : 0) - r + y, item: e ? J ? e.offsetWidth : e.offsetHeight : 0, itemWidth: e ? e.offsetWidth : 0, itemHeight: e ? e.offsetHeight : 0, viewportLength: J ? Math.max(document.documentElement.clientWidth || 0, v.innerWidth || 0, X.current.offsetWidth) : Math.max(document.documentElement.clientHeight || 0, v.innerHeight || 0, X.current.offsetHeight) }) }, []), dt = r(async () => { let e = new AbortController, [t, n] = Qe; if (!G && (!t.current || !n.current)) try { await Promise.all([z(t, e), q > 1 ? z(n, e) : !0]) } catch { e.abort() } C.read(ut, !1, !0) }, [ut]); o(() => { dt() }, [O]); let ft = a(!0); i(() => M(X.current, ({ contentSize: e }) => { !ft.current && (e.width || e.height) && (dt(), g(() => st(!0))), ft.current = !1 }), []), i(() => { if (Q) { let e = setTimeout(() => g(() => st(!1)), 500); return () => clearTimeout(e) } }, [Q]); let pt = K?.length, mt = G ? 0 : Z?.children, ht = Z?.item + y, gt = c * ht, [_t, $] = t(c + pt), [vt, yt] = t(!1); G && _t !== c && $(c); let bt = a(null), xt = b(bt), St = me() && xt, Ct = Y ? 1 : -1, wt = ee(mt), Tt = J ? -c * (Z?.itemWidth + y) : -c * (Z?.itemHeight + y), Et = () => Ct * _t * ht, Dt = G ? 0 : S(wt, e => { let t = x(-mt, -mt * 2, e); return isNaN(t) ? 0 : t }), Ot = x(0, pt, _t), kt = x(0, -pt, _t); o(() => { Z?.children !== null && !ft.current && Q && wt.set(Et()) }, [Z, mt, Ct, gt, _t, ht, Q]); let At = () => { G || !Ze || !Z.parent || vt || (wt.get() !== Et() && te(wt, Et(), ae), p && rt && (F || St) && ($e.current = setTimeout(() => { g(() => $(e => e + 1)), At() }, A * 1e3))) }, jt = (e, t = !1) => { Y ? t ? g(() => $(t => t - e)) : $(t => t - e) : t ? g(() => $(t => t + e)) : $(t => t + e) }, Mt = e => { let t = x(0, pt, _t), n = x(0, -pt, _t), r = e - t, i = e - Math.abs(n); g(Y ? () => $(e => e - i) : () => $(e => e + r)) }, Nt = () => { g(() => yt(!0)) }, Pt = (e, { offset: t, velocity: n }) => { g(() => yt(!1)); let r = J ? t.x : t.y, i = J ? n.x : n.y, a = r < -Z.item / 2, o = r > Z.item / 2, s = Math.abs(r), c = Math.round(s / Z.item), l = c === 0 ? 1 : c; i > 200 ? jt(-l, !0) : i < -200 ? jt(l, !0) : (a && jt(c, !0), o && jt(-c, !0)) }; i(() => { if (!(!St || Q || q <= 1)) return At(), () => $e.current && clearTimeout($e.current) }, [ct, St, Q]); let Ft = 0, It = `calc(${100 / O}% - ${y}px + ${y / O}px)`; for (let e = 0; e < lt; e++)ct = ct.concat(s.map(K, (t, n) => { let r; return e === 0 && (n === 0 ? r = Qe[0] : n === K.length - 1 && (r = Qe[1])), h(Te, { ref: r, slideKey: e + n + `lg`, index: e, width: J && O > 1 ? It : `100%`, height: J ? `100%` : O > 1 ? It : `100%`, size: Z, child: t, numChildren: K?.length, wrappedValue: Dt, childCounter: Ft++, gap: y, isCanvas: G, isHorizontal: J, effectsOpacity: N, effectsScale: ue, effectsRotate: de, children: e + n }, e + n + `lg`) })); let Lt = J ? `to right` : `to bottom`, Rt = R / 2, zt = 100 - R / 2, Bt = `linear-gradient(${Lt}, rgba(0, 0, 0, ${he}) ${we(pe, 0, Rt)}%, rgba(0, 0, 0, 1) ${Rt}%, rgba(0, 0, 0, 1) ${zt}%, rgba(0, 0, 0, ${he}) ${100 - pe}%)`, Vt = [], Ht = {}; if (Be) { for (let e = 0; e < K?.length; e++)Vt.push(h(Ee, { dotStyle: { ...Oe, width: Ve, height: Ve, backgroundColor: Ge }, buttonStyle: Se, selectedOpacity: qe, opacity: Je, onClick: () => Mt(e), wrappedIndex: Ot, wrappedIndexInverted: kt, total: pt, index: e, gap: W, padding: We, isHorizontal: J, isInverted: Y }, e)); Ye > 0 && (Ht.backdropFilter = Ht.WebkitBackdropFilter = `blur(${Ye}px)`) } let Ut = m ? { drag: J ? `x` : `y`, onDragStart: Nt, onDragEnd: Pt, dragDirectionLock: !0, values: { x: wt, y: wt }, dragMomentum: !1 } : {}, Wt = H === `top-left` || H === `top-mid` || H === `top-right`, Gt = H === `bottom-left` || H === `bottom-mid` || H === `bottom-right`, Kt = H === `top-left` || H === `bottom-left`, qt = H === `top-right` || H === `bottom-right`, Jt = H === `top-mid` || H === `bottom-mid` || H === `auto`; return u(`section`, { style: { ...ve, padding: Xe, WebkitMaskImage: I ? Bt : void 0, maskImage: I ? Bt : void 0, opacity: Z?.item === null ? _e : 1, userSelect: `none` }, onMouseEnter: () => { nt(!0), P || it(!1) }, onMouseLeave: () => { nt(!1), P || it(!0) }, onMouseDown: e => { e.preventDefault(), g(() => ot(!0)) }, onMouseUp: () => g(() => ot(!1)), ref: bt, children: [h(`div`, { style: { width: `100%`, height: `100%`, margin: 0, padding: `inherit`, position: `absolute`, inset: 0, overflow: L ? `visible` : `hidden`, borderRadius: se, userSelect: `none`, perspective: G ? `none` : fe }, children: h(E.ul, { ref: X, ...Ut, style: { ...ve, gap: y, placeItems: _, x: J ? G ? Tt : Dt : 0, y: J ? 0 : G ? Tt : Dt, flexDirection: J ? `row` : `column`, transformStyle: de !== 0 && !G ? `preserve-3d` : void 0, cursor: m ? at ? `grabbing` : `grab` : `auto`, userSelect: `none`, ...le }, children: ct }) }), u(`fieldset`, { style: { ...Ce }, "aria-label": `Slideshow pagination controls`, className: `framer--slideshow-controls`, children: [u(E.div, { style: { position: `absolute`, display: `flex`, flexDirection: J ? `row` : `column`, justifyContent: Ne ? `space-between` : `center`, gap: Ne ? `unset` : Fe, opacity: Pe ? _e : 1, alignItems: `center`, inset: U, top: Ne ? U : Wt ? Ie : `unset`, left: Ne ? U : Kt ? ze : Jt ? 0 : `unset`, right: Ne ? U : qt ? Le : Jt ? 0 : `unset`, bottom: Ne ? U : Gt ? Re : `unset` }, animate: Pe && { opacity: tt ? 1 : _e }, transition: ae, children: [h(E.button, { type: `button`, style: { ...Se, backgroundColor: Ae, width: B, height: B, borderRadius: ke, rotate: J ? 0 : 90, display: ge ? `block` : `none`, pointerEvents: `auto` }, onClick: () => jt(-1, !0), "aria-label": `Previous`, whileTap: { scale: .9 }, transition: { duration: .15 }, children: h(`img`, { decoding: `async`, width: B, height: B, src: je || `https://framerusercontent.com/images/6tTbkXggWgQCAJ4DO2QEdXXmgM.svg`, alt: `Back Arrow` }) }), h(E.button, { type: `button`, style: { ...Se, backgroundColor: Ae, width: B, height: B, borderRadius: ke, rotate: J ? 0 : 90, display: ge ? `block` : `none`, pointerEvents: `auto` }, onClick: () => jt(1, !0), "aria-label": `Next`, whileTap: { scale: .9 }, transition: { duration: .15 }, children: h(`img`, { decoding: `async`, width: B, height: B, src: Me || `https://framerusercontent.com/images/11KSGbIZoRSg4pjdnUoif6MKHI.svg`, alt: `Next Arrow` }) })] }), Vt.length > 1 ? h(`div`, { style: { ...De, left: J ? `50%` : He, top: J ? `unset` : `50%`, transform: J ? `translateX(-50%)` : `translateY(-50%)`, flexDirection: J ? `row` : `column`, bottom: J ? He : `unset`, borderRadius: Ue, backgroundColor: Ke, userSelect: `none`, ...Ht }, children: Vt }) : null] })] }) } var _e, ve, V, ye, be, xe, Se, Ce, we, Te, Ee, De, Oe, ke = e((() => { n(), l(), ae(), O(), T(), _(), ge(), _e = .001, B.defaultProps = { direction: `left`, dragControl: !1, startFrom: 0, itemAmount: 1, infinity: !0, gap: 10, padding: 10, autoPlayControl: !0, effectsOptions: { effectsOpacity: 1, effectsScale: 1, effectsRotate: 0, effectsPerspective: 1200, effectsHover: !0, playOffscreen: !1 }, transitionControl: { type: `spring`, stiffness: 200, damping: 40 }, fadeOptions: { fadeContent: !1, overflow: !1, fadeWidth: 25, fadeAlpha: 0, fadeInset: 0 }, arrowOptions: { showMouseControls: !0, arrowShouldFadeIn: !1, arrowShouldSpace: !0, arrowFill: `rgba(0,0,0,0.2)`, arrowSize: 40 }, progressOptions: { showProgressDots: !0 } }, D(B, { slots: { type: A.Array, title: `Content`, control: { type: A.ComponentInstance } }, direction: { type: A.Enum, title: `Direction`, options: [`left`, `right`, `top`, `bottom`], optionIcons: [`direction-left`, `direction-right`, `direction-up`, `direction-down`], optionTitles: [`Left`, `Right`, `Top`, `Bottom`], displaySegmentedControl: !0, defaultValue: B.defaultProps.direction }, autoPlayControl: { type: A.Boolean, title: `Auto Play`, defaultValue: !0 }, intervalControl: { type: A.Number, title: `Interval`, defaultValue: 1.5, min: .5, max: 10, step: .1, displayStepper: !0, unit: `s`, hidden: e => !e.autoPlayControl }, dragControl: { type: A.Boolean, title: `Draggable`, defaultValue: !1 }, startFrom: { type: A.Number, title: `Current`, min: 0, max: 10, displayStepper: !0, defaultValue: B.defaultProps.startFrom }, effectsOptions: { type: A.Object, title: `Effects`, controls: { effectsOpacity: { type: A.Number, title: `Opacity`, defaultValue: B.defaultProps.effectsOptions.effectsOpacity, min: 0, max: 1, step: .01, displayStepper: !0 }, effectsScale: { type: A.Number, title: `Scale`, defaultValue: B.defaultProps.effectsOptions.effectsScale, min: 0, max: 1, step: .01, displayStepper: !0 }, effectsPerspective: { type: A.Number, title: `Perspective`, defaultValue: B.defaultProps.effectsOptions.effectsPerspective, min: 200, max: 2e3, step: 1 }, effectsRotate: { type: A.Number, title: `Rotate`, defaultValue: B.defaultProps.effectsOptions.effectsRotate, min: -180, max: 180, step: 1 }, effectsHover: { type: A.Boolean, title: `On Hover`, enabledTitle: `Play`, disabledTitle: `Pause`, defaultValue: B.defaultProps.effectsOptions.effectsHover }, playOffscreen: { type: A.Boolean, title: `Offscreen`, enabledTitle: `Play`, disabledTitle: `Pause`, defaultValue: B.defaultProps.effectsOptions.playOffscreen } } }, alignment: { type: A.Enum, title: `Align`, options: [`flex-start`, `center`, `flex-end`], optionIcons: { direction: { right: [`align-top`, `align-middle`, `align-bottom`], left: [`align-top`, `align-middle`, `align-bottom`], top: [`align-left`, `align-center`, `align-right`], bottom: [`align-left`, `align-center`, `align-right`] } }, defaultValue: `center`, displaySegmentedControl: !0 }, itemAmount: { type: A.Number, title: `Items`, min: 1, max: 10, displayStepper: !0, defaultValue: B.defaultProps.itemAmount }, gap: { type: A.Number, title: `Gap`, min: 0 }, padding: { title: `Padding`, type: A.FusedNumber, toggleKey: `paddingPerSide`, toggleTitles: [`Padding`, `Padding per side`], defaultValue: 0, valueKeys: [`paddingTop`, `paddingRight`, `paddingBottom`, `paddingLeft`], valueLabels: [`T`, `R`, `B`, `L`], min: 0 }, borderRadius: { type: A.Number, title: `Radius`, min: 0, max: 500, displayStepper: !0, defaultValue: 0 }, transitionControl: { type: A.Transition, defaultValue: B.defaultProps.transitionControl, title: `Transition` }, fadeOptions: { type: A.Object, title: `Clipping`, controls: { fadeContent: { type: A.Boolean, title: `Fade`, defaultValue: !1 }, overflow: { type: A.Boolean, title: `Overflow`, enabledTitle: `Show`, disabledTitle: `Hide`, defaultValue: !1, hidden(e) { return e.fadeContent === !0 } }, fadeWidth: { type: A.Number, title: `Width`, defaultValue: 25, min: 0, max: 100, unit: `%`, hidden(e) { return e.fadeContent === !1 } }, fadeInset: { type: A.Number, title: `Inset`, defaultValue: 0, min: 0, max: 100, unit: `%`, hidden(e) { return e.fadeContent === !1 } }, fadeAlpha: { type: A.Number, title: `Opacity`, defaultValue: 0, min: 0, max: 1, step: .05, hidden(e) { return e.fadeContent === !1 } } } }, arrowOptions: { type: A.Object, title: `Arrows`, controls: { showMouseControls: { type: A.Boolean, title: `Show`, defaultValue: B.defaultProps.arrowOptions.showMouseControls }, arrowFill: { type: A.Color, title: `Fill`, hidden: e => !e.showMouseControls, defaultValue: B.defaultProps.arrowOptions.arrowFill }, leftArrow: { type: A.Image, title: `Previous`, hidden: e => !e.showMouseControls }, rightArrow: { type: A.Image, title: `Next`, hidden: e => !e.showMouseControls }, arrowSize: { type: A.Number, title: `Size`, min: 0, max: 200, displayStepper: !0, defaultValue: B.defaultProps.arrowOptions.arrowSize, hidden: e => !e.showMouseControls }, arrowRadius: { type: A.Number, title: `Radius`, min: 0, max: 500, defaultValue: 40, hidden: e => !e.showMouseControls }, arrowShouldFadeIn: { type: A.Boolean, title: `Fade In`, defaultValue: !1, hidden: e => !e.showMouseControls }, arrowShouldSpace: { type: A.Boolean, title: `Distance`, enabledTitle: `Space`, disabledTitle: `Group`, defaultValue: B.defaultProps.arrowOptions.arrowShouldSpace, hidden: e => !e.showMouseControls }, arrowPosition: { type: A.Enum, title: `Position`, options: [`auto`, `top-left`, `top-mid`, `top-right`, `bottom-left`, `bottom-mid`, `bottom-right`], optionTitles: [`Center`, `Top Left`, `Top Middle`, `Top Right`, `Bottom Left`, `Bottom Middle`, `Bottom Right`], hidden: e => !e.showMouseControls || e.arrowShouldSpace }, arrowPadding: { type: A.Number, title: `Inset`, min: -100, max: 100, defaultValue: 20, displayStepper: !0, hidden: e => !e.showMouseControls || !e.arrowShouldSpace }, arrowPaddingTop: { type: A.Number, title: `Top`, min: -500, max: 500, defaultValue: 0, displayStepper: !0, hidden: e => !e.showMouseControls || e.arrowShouldSpace || e.arrowPosition === `auto` || e.arrowPosition === `bottom-mid` || e.arrowPosition === `bottom-left` || e.arrowPosition === `bottom-right` }, arrowPaddingBottom: { type: A.Number, title: `Bottom`, min: -500, max: 500, defaultValue: 0, displayStepper: !0, hidden: e => !e.showMouseControls || e.arrowShouldSpace || e.arrowPosition === `auto` || e.arrowPosition === `top-mid` || e.arrowPosition === `top-left` || e.arrowPosition === `top-right` }, arrowPaddingRight: { type: A.Number, title: `Right`, min: -500, max: 500, defaultValue: 0, displayStepper: !0, hidden: e => !e.showMouseControls || e.arrowShouldSpace || e.arrowPosition === `auto` || e.arrowPosition === `top-left` || e.arrowPosition === `top-mid` || e.arrowPosition === `bottom-left` || e.arrowPosition === `bottom-mid` }, arrowPaddingLeft: { type: A.Number, title: `Left`, min: -500, max: 500, defaultValue: 0, displayStepper: !0, hidden: e => !e.showMouseControls || e.arrowShouldSpace || e.arrowPosition === `auto` || e.arrowPosition === `top-right` || e.arrowPosition === `top-mid` || e.arrowPosition === `bottom-right` || e.arrowPosition === `bottom-mid` }, arrowGap: { type: A.Number, title: `Gap`, min: 0, max: 100, defaultValue: 10, displayStepper: !0, hidden: e => !e.showMouseControls || e.arrowShouldSpace } } }, progressOptions: { type: A.Object, title: `Dots`, controls: { showProgressDots: { type: A.Boolean, title: `Show`, defaultValue: !1 }, dotSize: { type: A.Number, title: `Size`, min: 1, max: 100, defaultValue: 10, displayStepper: !0, hidden: e => !e.showProgressDots || e.showScrollbar }, dotsInset: { type: A.Number, title: `Inset`, min: -100, max: 100, defaultValue: 10, displayStepper: !0, hidden: e => !e.showProgressDots || e.showScrollbar }, dotsGap: { type: A.Number, title: `Gap`, min: 0, max: 100, defaultValue: 10, displayStepper: !0, hidden: e => !e.showProgressDots || e.showScrollbar }, dotsPadding: { type: A.Number, title: `Padding`, min: 0, max: 100, defaultValue: 10, displayStepper: !0, hidden: e => !e.showProgressDots || e.showScrollbar }, dotsFill: { type: A.Color, title: `Fill`, defaultValue: `#fff`, hidden: e => !e.showProgressDots || e.showScrollbar }, dotsBackground: { type: A.Color, title: `Backdrop`, defaultValue: `rgba(0,0,0,0.2)`, hidden: e => !e.showProgressDots || e.showScrollbar }, dotsRadius: { type: A.Number, title: `Radius`, min: 0, max: 200, defaultValue: 50, hidden: e => !e.showProgressDots || e.showScrollbar }, dotsOpacity: { type: A.Number, title: `Opacity`, min: 0, max: 1, defaultValue: .5, step: .1, displayStepper: !0, hidden: e => !e.showProgressDots || e.showScrollbar }, dotsActiveOpacity: { type: A.Number, title: `Current`, min: 0, max: 1, defaultValue: 1, step: .1, displayStepper: !0, hidden: e => !e.showProgressDots || e.showScrollbar }, dotsBlur: { type: A.Number, title: `Blur`, min: 0, max: 50, defaultValue: 0, step: 1, hidden: e => !e.showProgressDots || e.showScrollbar } } } }), ve = { display: `flex`, flexDirection: `row`, width: `100%`, height: `100%`, maxWidth: `100%`, maxHeight: `100%`, placeItems: `center`, margin: 0, padding: 0, listStyleType: `none`, textIndent: `none` }, V = { display: `flex`, width: `100%`, height: `100%`, placeContent: `center`, placeItems: `center`, flexDirection: `column`, color: `#96F`, background: `rgba(136, 85, 255, 0.1)`, fontSize: 11, overflow: `hidden`, padding: `20px 20px 30px 20px` }, ye = { fontSize: 32, marginBottom: 10 }, be = { margin: 0, marginBottom: 10, fontWeight: 600, textAlign: `center` }, xe = { margin: 0, opacity: .7, maxWidth: 180, lineHeight: 1.5, textAlign: `center` }, Se = { border: `none`, display: `flex`, placeContent: `center`, placeItems: `center`, overflow: `hidden`, background: `transparent`, cursor: `pointer`, margin: 0, padding: 0 }, Ce = { display: `flex`, justifyContent: `space-between`, alignItems: `center`, position: `absolute`, pointerEvents: `none`, userSelect: `none`, top: 0, left: 0, right: 0, bottom: 0, border: 0, padding: 0, margin: 0 }, we = (e, t, n) => Math.min(Math.max(e, t), n), Te = d(c(function (e, t) { let { slideKey: n, width: r, height: o, child: s, size: c, gap: l, wrappedValue: u, numChildren: d, childCounter: f, isCanvas: m, effects: g, effectsOpacity: _, effectsScale: v, effectsRotate: b, isHorizontal: x, isLast: ee, index: te } = e, C = a(), ne = (c?.item + l) * f, w = [-c?.item, 0, c?.parent - c?.item + l, c?.parent].map(e => e - ne), T = !m && S(u, w, [-b, 0, 0, b]), E = !m && S(u, w, [b, 0, 0, -b]), ie = !m && S(u, w, [_, 1, 1, _]), D = !m && S(u, w, [v, 1, 1, v]), O = !m && S(u, w, [1, 1, 0, 0]), k = !m && S(u, e => e >= w[1] && e <= w[2]); i(() => { if (k) return k.on(`change`, e => { (t?.current ?? C.current)?.setAttribute(`aria-hidden`, !e) }) }, []); let A = m ? `visible` : S(u, [w[0] - c.viewportLength, y(w[1], w[2], .5), w[3] + c.viewportLength], [`hidden`, `visible`, `hidden`]), j = n + `child`; return h(re, { inherit: `id`, id: j, children: h(`li`, { style: { display: `contents` }, "aria-hidden": te !== 0, children: p(s, { ref: t ?? C, key: j, style: { ...s.props?.style, flexShrink: 0, userSelect: `none`, width: r, height: o, opacity: ie, scale: D, originX: x ? O : .5, originY: x ? .5 : O, rotateY: x ? T : 0, rotateX: x ? 0 : E, visibility: A }, layoutId: s.props.layoutId ? s.props.layoutId + `-original-` + te : void 0 }) }) }) })), Ee = d(function ({ selectedOpacity: e, opacity: t, total: n, index: r, wrappedIndex: i, wrappedIndexInverted: a, dotStyle: o, buttonStyle: s, gap: c, padding: l, isHorizontal: u, isInverted: d, ...f }) { let p = i === r; d && (p = Math.abs(a) === r); let m = c / 2, g = !u && r > 0 ? m : l, _ = !u && r !== n - 1 ? m : l, v = u && r !== n - 1 ? m : l, y = u && r > 0 ? m : l; return h(`button`, { "aria-label": `Scroll to page ${r + 1}`, type: `button`, ...f, style: { ...s, padding: `${g}px ${v}px ${_}px ${y}px` }, children: h(E.div, { style: { ...o }, initial: !1, animate: { opacity: p ? e : t }, transition: { duration: .3 } }) }) }), De = { display: `flex`, placeContent: `center`, placeItems: `center`, overflow: `hidden`, position: `absolute`, pointerEvents: `auto` }, Oe = { borderRadius: `50%`, background: `white`, cursor: `pointer`, border: `none`, placeContent: `center`, placeItems: `center`, padding: 0 } })), Ae = e((() => { L() })); function je(e) { var t = typeof e; return e != null && (t == `object` || t == `function`) } function Me(e) { if (typeof e == `number`) return e; if (typeof e == `symbol`) return Ie; if (je(e)) { var t = typeof e.valueOf == `function` ? e.valueOf() : e; e = je(t) ? t + `` : t } if (typeof e != `string`) return e === 0 ? e : +e; e = e.replace(Le, ``); var n = ze.test(e); return n || Be.test(e) ? Ve(e.slice(2), n ? 2 : 8) : Re.test(e) ? Ie : +e } function Ne(e, t, n) { var r, i, a, o, s, c, l = 0, u = !1, d = !1, f = !0; if (typeof e != `function`) throw TypeError(H); t = Me(t) || 0, je(n) && (u = !!n.leading, d = `maxWait` in n, a = d ? U(Me(n.maxWait) || 0, t) : a, f = `trailing` in n ? !!n.trailing : f); function p(t) { var n = r, a = i; return r = i = void 0, l = t, o = e.apply(a, n), o } function m(e) { return l = e, s = setTimeout(_, t), u ? p(e) : o } function h(e) { var n = e - c, r = e - l, i = t - n; return d ? Fe(i, a - r) : i } function g(e) { var n = e - c, r = e - l; return c === void 0 || n >= t || n < 0 || d && r >= a } function _() { var e = He(); if (g(e)) return v(e); s = setTimeout(_, h(e)) } function v(e) { return s = void 0, f && r ? p(e) : (r = i = void 0, o) } function y() { s !== void 0 && clearTimeout(s), l = 0, r = c = i = s = void 0 } function b() { return s === void 0 ? o : v(He()) } function x() { var e = He(), n = g(e); if (r = arguments, i = this, c = e, n) { if (s === void 0) return m(c); if (d) return clearTimeout(s), s = setTimeout(_, t), p(c) } return s === void 0 && (s = setTimeout(_, t)), o } return x.cancel = y, x.flush = b, x } function Pe(e, t, n) { var r = !0, i = !0; if (typeof e != `function`) throw TypeError(H); return je(n) && (r = `leading` in n ? !!n.leading : r, i = `trailing` in n ? !!n.trailing : i), Ne(e, t, { leading: r, maxWait: t, trailing: i }) } var H, U, Fe, Ie, Le, Re, ze, Be, Ve, He, Ue = e((() => { H = `Expected a function`, U = Math.max, Fe = Math.min, Ie = NaN, Le = /^\s+|\s+$/g, Re = /^[-+]0x[0-9a-f]+$/i, ze = /^0b[01]+$/i, Be = /^0o[0-7]+$/i, Ve = parseInt, He = function () { return Date.now() } })), We = e((() => { Ue() })), W, Ge, Ke = e((() => {
    l(), O(), T(), _(), Ae(), We(), (function (e) { e.Hide = `Hide`, e.Hover = `Hover`, e.Show = `Show` })(W ||= {}), Ge = k(function (e) {
        let { value: n, trackHeight: i, fillColor: o, focusColor: s, min: c, max: l, onChange: d, onChangeLive: f, onMax: p, onMin: m, trackColor: g, trackRadius: _, knobSize: v, knobColor: y, constrainKnob: b, shadow: x, shouldAnimateChange: ee, transition: C, overdrag: re, knobSetting: w, style: T } = e, [ie, D] = t(!1), [O, k] = t(!1), A = j.current() === j.canvas, M = ee && !A, ae = b && w === W.Show, oe = w !== W.Hide, se = a(), le = r((e, t) => { P(e), d && d(e), M ? te(t, e, C) : requestAnimationFrame(() => t.set(e)) }, [C, M, d]), N = de(n, { onChange: le, transform: e => ne(e, [0, 100], [c, l]) }), ue = S(N, [c, l], [`0%`, `100%`]), fe = S(N, [c, l], [0, 1]), P = r(Pe(e => { se.current?.value && (se.current.value = e) }, 100), [se]); ce(N, e => { F(n) && P(e), p && e >= l && p(), m && e <= c && m(), f && f(e) }); let I = e => { le(parseFloat(e.target.value), N) }, L = e => { parseFloat(e.target.value) !== 0 && le(parseFloat(e.target.value), N) }, R = () => { }, pe = oe ? v + 8 : 8, me = Math.max(v + 8, i); return u(`div`, {
            className: `framer-default-slider`, onMouseEnter: () => D(!0), onMouseLeave: () => D(!1), style: { position: `relative`, ...T, alignItems: `center`, justifyContent: `flex-start`, border: `0px solid ${s}`, "--framer-default-slider-height": me, "--framer-default-slider-width": pe }, children: [h(`input`, { ref: se, style: { flexShrink: 0, minHeight: me, opacity: 0, margin: 0, display: `flex`, ...T, WebkitTapHighlightColor: `rgba(0, 0, 0, 0)`, ...!ae && { width: `calc(100% + ${pe}px)`, marginLeft: -pe / 2 } }, onFocus: () => k(!0), onBlur: () => k(!1), type: `range`, min: c, max: l, defaultValue: -1, step: `any`, onChange: I, onMouseDown: L, onMouseUp: R }), h(`div`, { style: { background: g, position: `absolute`, top: `calc(50% - ${Math.ceil(i / 2)}px)`, borderRadius: _, display: `flex`, height: i, width: `100%`, transformOrigin: `left`, pointerEvents: `none`, overflow: `hidden` }, children: h(E.div, { style: { height: i, width: `100%`, background: o, scaleX: fe, position: `absolute`, top: `calc(50% - ${Math.ceil(i / 2)}px)`, transformOrigin: `left`, pointerEvents: `none` } }) }), h(E.div, {
                style: { x: ue, position: `absolute`, display: `flex`, top: `calc(50% - ${Math.floor(v / 2)}px)`, pointerEvents: `none`, ...ae ? { width: `calc(100% - ${v}px`, left: 0 } : { width: `100%`, left: -v / 2 } }, children: h(E.div, {
                    initial: !1, animate: { scale: ie && w === W.Hover || w === W.Show ? 1 : 0 }, transition: { type: `spring`, stiffness: 900, damping: 40 }, style: {
                        transformOrigin: `50% 50%`, width: v, height: v, borderRadius: `50%`, background: y, pointerEvents: `none`, boxShadow: `0px 1px 2px 0px ${x}, 
                                0px 2px 4px 0px ${x}, 
                                0px 4px 8px 0px ${x}`
                    }
                })
            })]
        })
    }, [`.framer-default-slider input[type=range] {  width: 100%; height: 100% background:transparent margin: 0;}`, `.framer-default-slider input[type=range]:focus { outline: none; }`, `.framer-default-slider input[type=range]::-ms-track { width: 100%; cursor: pointer; background: transparent; border-color: transparent; color: transparent; }`, `.framer-default-slider input[type=range]::-webkit-slider-thumb { height: var(--framer-default-slider-height, 0px); width: var(--framer-default-slider-width, 0px); border-radius: 0;  background: none; }`, `.framer-default-slider input[type=range]::-moz-range-thumb { height: var(--framer-default-slider-height, 0px); width: var(--framer-default-slider-width, 0px); border-radius: 0;  background: none; }`, `.framer-default-slider input[type=range]::-ms-thumb  { height: var(--framer-default-slider-height, 0px); width: var(--framer-default-slider-width, 0px); border-radius: 0;  background: none; }`]), Ge.displayName = `Slider`, Ge.defaultProps = { height: 20, width: 200, trackHeight: 4, fillColor: `#09F`, trackColor: `#DDD`, knobColor: `#FFF`, focusColor: `rgba(0, 153, 255,0)`, shadow: `rgba(0,0,0,0.1)`, knobSize: 20, overdrag: !0, min: 0, max: 100, value: 50, trackRadius: 5, knobSetting: W.Show, constrainKnob: !1, transition: { type: `spring`, delay: 0, stiffness: 750, damping: 50 }, shouldAnimateChange: !0 }, D(Ge, { fillColor: { title: `Tint`, type: A.Color }, trackColor: { title: `Track`, type: A.Color }, knobColor: { title: `Knob`, type: A.Color }, shadow: { type: A.Color, title: `Shadow` }, shouldAnimateChange: { type: A.Boolean, title: `Changes`, enabledTitle: `Animate`, disabledTitle: `Instant` }, transition: { type: A.Transition, defaultValue: Ge.defaultProps.transition }, knobSetting: { type: A.Enum, displaySegmentedControl: !0, title: `Knob`, options: [`Hide`, `Hover`, `Show`] }, constrainKnob: { type: A.Boolean, title: `Constrain`, enabledTitle: `Yes`, disabledTitle: `No`, hidden: ({ knobSetting: e }) => e !== W.Show }, knobSize: { type: A.Number, title: `Knob`, min: 10, max: 100, hidden: ({ knobSetting: e }) => e === W.Hide }, value: { type: A.Number, title: `Value`, min: 0, max: 100, unit: `%` }, trackHeight: { title: `Height`, type: A.Number, min: 0 }, min: { title: `Min`, type: A.Number, displayStepper: !0 }, trackRadius: { type: A.Number, displayStepper: !0, min: 0, max: 200, title: `Radius` }, max: { title: `Max`, type: A.Number, displayStepper: !0 }, onChange: { type: A.EventHandler }, onMax: { type: A.EventHandler }, onMin: { type: A.EventHandler } })
})); function qe(e) { let { currentTime: n, startTime: r } = e, [a, o] = t(`0:00`); return i(() => { o(R(r)) }, [r]), ce(n, e => { o(R(e)) }), h(m, { children: a }) } function Je(e) { return h(E.svg, { ...e, className: `framer-audio-icon`, xmlns: `http://www.w3.org/2000/svg`, viewBox: `0 0 16 16`, children: h(`path`, { d: `M 5.379 1.292 C 4.968 1.033 4.449 1.017 4.023 1.251 C 3.598 1.486 3.334 1.933 3.333 2.419 L 3.333 13.581 C 3.334 14.067 3.598 14.514 4.023 14.749 C 4.449 14.983 4.968 14.967 5.379 14.708 L 14.215 9.127 C 14.602 8.883 14.836 8.457 14.836 8 C 14.836 7.543 14.602 7.117 14.215 6.873 Z`, fill: `#333` }) }) } function Ye(e) { return u(E.svg, { ...e, className: `framer-audio-icon`, xmlns: `http://www.w3.org/2000/svg`, viewBox: `0 0 16 16`, children: [h(`path`, { d: `M 3 3 C 3 2.448 3.448 2 4 2 L 6 2 C 6.552 2 7 2.448 7 3 L 7 13 C 7 13.552 6.552 14 6 14 L 4 14 C 3.448 14 3 13.552 3 13 Z`, fill: `#343434` }), h(`path`, { d: `M 9 3 C 9 2.448 9.448 2 10 2 L 12 2 C 12.552 2 13 2.448 13 3 L 13 13 C 13 13.552 12.552 14 12 14 L 10 14 C 9.448 14 9 13.552 9 13 Z`, fill: `#343434` })] }) } var Xe, G, K, q, Ze = e((() => { l(), _(), O(), T(), Ae(), Ke(), Xe = e => e instanceof w, (function (e) { e.Video = `Upload`, e.Url = `URL` })(G ||= {}), K = e => e.current && !e.current.paused && !e.current.ended && e.current.readyState > 2, q = k(function (e) { let { playing: n, background: o, progressColor: s, trackHeight: c, gap: l, trackColor: d, srcUrl: f, srcType: p, srcFile: g, loop: _, font: v, autoPlay: y, progress: b, volume: x, showTime: S, showTrack: ee, playPauseCursor: C, showPlayPause: ne, onTimeUpdate: re, onMetadata: w, onPlay: T, onPause: E, onEnd: D, pauseOnExit: O, onPlayGlobalPauseOption: k } = e, A = `pointer`; C ? A = C : e != null && e.style?.cursor && (A = e.style.cursor); let [M, ae] = t(!1), [ce, P] = t(0), F = a(), I = a({ ready: !1, animation: null }), L = de(b, { transform: e => e * .01, onChange: (e, t) => { F.current.duration && (F.current.currentTime = e * F.current.duration, V(`motionHook`)) } }), me = ue(e), he = oe(e), { fontSize: ge } = se(e), z = j.current() === j.preview, B = k === `pause`, _e = p === `URL` ? f : g, ve = z && n, V = r(e => { var t, n; let r = F.current.duration, i = F.current.currentTime; if ((n = I.current) == null || (t = n.animation) == null || t.stop(), Math.abs(i - L.get()) > .5 && L.set(i), !z) return; let a = K(F); M !== a && ae(a), a && z && (I.current.animation = te(L, r, { type: `tween`, ease: `linear`, duration: r - i })) }, [z, M]), ye = () => { document.querySelectorAll(`.framer-audio`).forEach(e => { e.pause() }) }, be = () => { z && F.current.play().catch(e => { }) }, xe = () => { var e, t; F.current.pause(), (t = I.current) == null || (e = t.animation) == null || e.stop() }, Se = () => { w && w({ duration: F.current.duration }), P(F.current.duration) }, Ce = () => { Xe(b) || (F.current.currentTime = b * .01 * F.current.duration) }, we = () => { I.current.ready || (ve && be(), I.current.ready = !0, Ce()) }, Te = e => { F.current.currentTime && (F.current.currentTime = e, V(`handleSeek`)) }, Ee = () => { D && D() }, De = () => { B && ye(), be() }; i(() => { z ? n === !0 ? be() : xe() : ae(n === !0) }, [n]), i(() => { F.current?.duration && P(F.current.duration) }, []), i(() => { I.current.ready && M && T ? T() : I.current.ready && E && E() }, [M]), i(() => { F.current.volume = x / 100 }, [x]), i(() => { I.current.ready = !1 }, [g, p, f]), fe(() => { ve && be() }), N(() => { O && F.current.pause() }), ie(L, `change`, e => { let t = F.current?.duration ? e / F.current.duration * 100 : null; re && re(e, t, R(e)) }); let Oe = { marginRight: S || ee ? l : 0, flexShrink: 0, cursor: A }; return u(`div`, { style: { ...le, position: `relative`, overflow: `hidden`, background: o, padding: me, borderRadius: he }, children: [h(`audio`, { src: _e, loop: _, className: `framer-audio`, ref: F, preload: `metadata`, autoPlay: ve, onLoadedMetadata: Se, onCanPlayThrough: we, onPlaying: () => V(`playingEvent`), onPlay: () => V(`playEvent`), onSeeked: () => V(`seekEvent`), onPause: () => V(`pauseEvent`), onEnded: () => Ee() }), ne && h(m, { children: M ? h(Ye, { width: 16, whileTap: { scale: .9 }, onClick: () => xe(), style: Oe, "aria-label": `pause audio` }) : h(Je, { width: 16, whileTap: { scale: .9 }, onClick: De, style: Oe, "aria-label": `play audio` }) }), S && u(`p`, { style: { userSelect: `none`, color: `#333`, fontWeight: 500, letterSpacing: -.25, margin: 0, flexShrink: 0, fontFamily: pe, fontVariantNumeric: `tabular-nums`, marginRight: ee ? l : 0, ...v }, children: [h(qe, { startTime: ce * (Xe(b) ? b.get() : b * .01), currentTime: L }), h(`span`, { style: { padding: `0 2px` }, children: `/` }), ce > 0 ? R(ce) : `1:34`] }), ee && h(Ge, { style: { width: `100%` }, value: L, fillColor: s, knobSetting: `Hover`, shadow: `rgba(0,0,0,0)`, knobSize: 10, knobColor: s, onChange: Te, shouldAnimateChange: !1, min: 0, max: ce, trackColor: d })] }) }, [`.framer-audio-icon { outline: none; }`, `.framer-audio-icons:focus-visible { outline: auto; }`]), q.defaultProps = { background: `#EBEBEB`, trackColor: `#FFFFFF`, font: { fontSize: 12 }, progressColor: `#333333`, srcUrl: `https://assets.mixkit.co/music/preview/mixkit-tech-house-vibes-130.mp3`, srcType: `URL`, pauseOnExit: !0, borderRadius: 8, padding: 15, progress: 0, volume: 25, loop: !1, playing: !0, autoPlay: !0, showTime: !0, showTrack: !0, showPlayPause: !0, onPlayGlobalPauseOption: `continue`, trackHeight: 4, gap: 15, height: 50, width: 240 }, D(q, { srcType: { type: A.Enum, displaySegmentedControl: !0, title: `Source`, options: [`URL`, `Upload`] }, srcUrl: { type: A.String, title: ` `, placeholder: `.../example.mp4`, hidden(e) { return e.srcType === `Upload` } }, srcFile: { type: A.File, title: ` `, allowedFileTypes: [`mp4`, `mp3`, `wav`, `m4a`], hidden(e) { return e.srcType === `URL` } }, playing: { title: `Playing`, type: A.Boolean, enabledTitle: `Yes`, disabledTitle: `No` }, loop: { title: `Loop`, type: A.Boolean, enabledTitle: `Yes`, disabledTitle: `No` }, progress: { title: `Progress`, type: A.Number, max: 100, min: 0, unit: `%` }, volume: { type: A.Number, max: 100, min: 0, unit: `%` }, progressColor: { title: `Progress`, type: A.Color, defaultValue: q.defaultProps.progressColor }, trackColor: { title: `Track`, type: A.Color, defaultValue: q.defaultProps.trackColor }, background: { title: `Player`, type: A.Color, defaultValue: q.defaultProps.background }, font: { title: `Font`, type: A.Font, displayFontSize: !0 }, ...I, ...P, gap: { type: A.Number, min: 0, max: 100, displayStepper: !0 }, showPlayPause: { type: A.Boolean, title: `Play/Pause`, enabledTitle: `Show`, disabledTitle: `Hide` }, showTrack: { type: A.Boolean, title: `Track`, enabledTitle: `Show`, disabledTitle: `Hide` }, showTime: { type: A.Boolean, title: `Time`, enabledTitle: `Show`, disabledTitle: `Hide` }, pauseOnExit: { type: A.Boolean, title: `On Leave`, enabledTitle: `Pause`, disabledTitle: `Continue` }, onPlayGlobalPauseOption: { type: A.Enum, title: `On Play`, options: [`continue`, `pause`], optionTitles: [`Continue All`, `Pause All`] }, onPlay: { type: A.EventHandler }, onPause: { type: A.EventHandler }, onEnd: { type: A.EventHandler }, onTimeUpdate: { type: A.EventHandler } }) })); function J() { let [e, n] = t(0); return r(() => g(() => n(e => e + 1)), []) } function Y(e, t) { return t ? e : (e < 10 ? `0` : ``) + e } function X(e, t) { return h(`span`, { style: { color: e }, children: t }) } function Qe(e, { showHours: t, showMinutes: n, showSeconds: r }, { dayLabel: i, hourLabel: a, minuteLabel: o, secondLabel: s }, { space: c, spaceForLabel: l, labelType: d }, f) { let p = u(m, { children: [e.days, c, t ? X(f, `:`) : ``] }), h = t ? u(m, { children: [e.hours, c, n ? X(f, `:`) : ``] }) : ``, g = t && n ? u(m, { children: [e.minutes, c, r ? X(f, `:`) : ``] }) : ``, _ = t && n && r ? e.seconds : ``; return d || (p = u(m, { children: [e.days, l, X(f, i)] }), h = t ? u(m, { children: [e.hours, l, X(f, a)] }) : ``, g = n ? u(m, { children: [e.minutes, l, X(f, o)] }) : ``, _ = r ? u(m, { children: [e.seconds, l, X(f, s)] }) : ``), u(m, { children: [p, c, h, c, g, c, _] }) } function $e(e) { let { date: n, pickTime: r, font: o, color: s, labelColor: c, displayProps: l, onComplete: u } = e, { digitCount: d, labelType: f, numberSpace: p, labelSpace: m, dayLabel: _, hourLabel: v, minuteLabel: y, secondLabel: b, showHours: x, showMinutes: S, showSeconds: ee, tabularFont: te } = l, [C, ne] = t(!1), re = new Date(n).setUTCHours(r) - +new Date, w = a(0); re <= 0 && (u?.(), clearTimeout(w.current)); let T = j.current() === j.canvas, E = J(); i(() => { if (g(() => ne(!0)), T) return; function e() { let t = new Date, n = new Date().setSeconds(t.getSeconds() + 1, 0) - +t; w.current = setTimeout(e, n), E() } return e(), () => clearTimeout(w.current) }, [T, E]); let ie = Qe(et(re, d), { showHours: x, showMinutes: S, showSeconds: ee }, { dayLabel: _, hourLabel: v, minuteLabel: y, secondLabel: b }, { space: p ? `` : ` `, spaceForLabel: m ? `` : ` `, labelType: f }, c); return h(`p`, { suppressHydrationWarning: !0, style: { color: s, fontFamily: Z, fontWeight: 500, fontSize: 16, lineHeight: 1, ...o, margin: 0, padding: 0, visibility: C ? `visible` : `hidden`, fontVariantNumeric: te ? `tabular-nums` : `normal`, whiteSpace: `nowrap` }, children: re > 0 ? ie : `00:00:00:00` }) } var Z, et, tt, nt = e((() => { l(), O(), _(), Z = `"Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`, et = (e, t) => e > 0 ? { days: Y(Math.floor(e / (1e3 * 60 * 60 * 24)), t), hours: Y(Math.floor(e / (1e3 * 60 * 60) % 24), t), minutes: Y(Math.floor(e / 1e3 / 60 % 60), t), seconds: Y(Math.floor(e / 1e3 % 60), t) } : { days: 0, hours: 0, minutes: 0, seconds: 0 }, $e.displayName = `Countdown`, tt = new Date, tt.setDate(tt.getDate() + 2), D($e, { date: { type: A.Date, title: `Date`, defaultValue: tt.toISOString() }, pickTime: { type: A.Number, min: 0, max: 24, defaultValue: 0, step: 1, displayStepper: !0, title: `UTC`, unit: `:00` }, displayProps: { type: A.Object, title: `Style`, buttonTitle: `Dots, Labels`, icon: `boolean`, controls: { digitCount: { title: `Digits`, type: A.Boolean, enabledTitle: `One`, disabledTitle: `Two`, defaultValue: !1 }, labelType: { title: `Type`, type: A.Boolean, enabledTitle: `Dots`, disabledTitle: `Custom`, defaultValue: !0 }, numberSpace: { type: A.Boolean, title: `Number`, enabledTitle: `Auto`, disabledTitle: `Space`, defaultValue: !1 }, labelSpace: { type: A.Boolean, title: `Label`, enabledTitle: `Auto`, disabledTitle: `Space`, defaultValue: !0, hidden: e => e.labelType }, dayLabel: { type: A.String, title: `Days`, defaultValue: `D`, placeholder: `D`, hidden: e => e.labelType }, showHours: { title: `Hours`, type: A.Boolean, enabledTitle: `Show`, disabledTitle: `Hide`, defaultValue: !0 }, hourLabel: { type: A.String, title: ` `, defaultValue: `H`, placeholder: `H`, hidden: e => e.labelType || !e.showHours }, showMinutes: { title: `Minutes`, type: A.Boolean, enabledTitle: `Show`, disabledTitle: `Hide`, defaultValue: !0, hidden: e => !e.showHours }, minuteLabel: { type: A.String, title: ` `, defaultValue: `M`, placeholder: `M`, hidden: e => e.labelType || !e.showHours || !e.showMinutes }, showSeconds: { title: `Seconds`, type: A.Boolean, enabledTitle: `Show`, disabledTitle: `Hide`, defaultValue: !0, hidden: e => !e.showHours || !e.showMinutes }, secondLabel: { type: A.String, title: ` `, defaultValue: `S`, placeholder: `S`, hidden: e => e.labelType || !e.showHours || !e.showMinutes || !e.showSeconds }, tabularFont: { title: `Tabular`, type: A.Boolean, defaultValue: !0 } } }, font: { type: A.Font, controls: `extended` }, color: { type: A.Color, defaultValue: `#999` }, labelColor: { title: `Label`, type: A.Color, defaultValue: `rgba(153,153,153,0.5)` }, onComplete: { type: A.EventHandler } }) })); function rt(e, t, n) { return Math.max(e, Math.min(t, n)) } var it, at, ot, Q, st, ct, lt = e((() => { n(), it = class { constructor() { this.isRunning = !1, this.value = 0, this.from = 0, this.to = 0, this.duration = 0, this.currentTime = 0 } advance(e) { var t; if (!this.isRunning) return; let n = !1; if (this.duration && this.easing) { this.currentTime += e; let t = rt(0, this.currentTime / this.duration, 1); n = t >= 1; let r = n ? 1 : this.easing(t); this.value = this.from + (this.to - this.from) * r } else this.lerp ? (this.value = function (e, t, n, r) { return function (e, t, n) { return (1 - n) * e + n * t }(e, t, 1 - Math.exp(-n * r)) }(this.value, this.to, 60 * this.lerp, e), Math.round(this.value) === this.to && (this.value = this.to, n = !0)) : (this.value = this.to, n = !0); n && this.stop(), (t = this.onUpdate) == null || t.call(this, this.value, n) } stop() { this.isRunning = !1 } fromTo(e, t, { lerp: n, duration: r, easing: i, onStart: a, onUpdate: o }) { this.from = this.value = e, this.to = t, this.lerp = n, this.duration = r, this.easing = i, this.currentTime = 0, this.isRunning = !0, a?.(), this.onUpdate = o } }, at = class { constructor({ wrapper: e, content: t, autoResize: n = !0, debounce: r = 250 } = {}) { this.width = 0, this.height = 0, this.scrollWidth = 0, this.scrollHeight = 0, this.resize = () => { this.onWrapperResize(), this.onContentResize() }, this.onWrapperResize = () => { this.wrapper === v ? (this.width = v.innerWidth, this.height = v.innerHeight) : this.wrapper instanceof HTMLElement && (this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight) }, this.onContentResize = () => { this.wrapper === v ? (this.scrollHeight = this.content.scrollHeight, this.scrollWidth = this.content.scrollWidth) : this.wrapper instanceof HTMLElement && (this.scrollHeight = this.wrapper.scrollHeight, this.scrollWidth = this.wrapper.scrollWidth) }, this.wrapper = e, this.content = t, n && (this.debouncedResize = function (e, t) { let n; return function () { let r = arguments, i = this; clearTimeout(n), n = setTimeout((function () { e.apply(i, r) }), t) } }(this.resize, r), this.wrapper === v ? v.addEventListener(`resize`, this.debouncedResize, !1) : (this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(this.debouncedResize), this.contentResizeObserver.observe(this.content)), this.resize() } destroy() { var e, t; (e = this.wrapperResizeObserver) == null || e.disconnect(), (t = this.contentResizeObserver) == null || t.disconnect(), v.removeEventListener(`resize`, this.debouncedResize, !1) } get limit() { return { x: this.scrollWidth - this.width, y: this.scrollHeight - this.height } } }, ot = class { constructor() { this.events = {} } emit(e, ...t) { let n = this.events[e] || []; for (let e = 0, r = n.length; e < r; e++)n[e](...t) } on(e, t) { var n; return (n = this.events[e]) != null && n.push(t) || (this.events[e] = [t]), () => { this.events[e] = this.events[e]?.filter((e => t !== e)) } } off(e, t) { this.events[e] = this.events[e]?.filter((e => t !== e)) } destroy() { this.events = {} } }, Q = 100 / 6, st = class { constructor(e, { wheelMultiplier: t = 1, touchMultiplier: n = 1 }) { this.lastDelta = { x: 0, y: 0 }, this.windowWidth = 0, this.windowHeight = 0, this.onTouchStart = e => { let { clientX: t, clientY: n } = e.targetTouches ? e.targetTouches[0] : e; this.touchStart.x = t, this.touchStart.y = n, this.lastDelta = { x: 0, y: 0 }, this.emitter.emit(`scroll`, { deltaX: 0, deltaY: 0, event: e }) }, this.onTouchMove = e => { let { clientX: t, clientY: n } = e.targetTouches ? e.targetTouches[0] : e, r = -(t - (this.touchStart?.x ?? 0)) * this.touchMultiplier, i = -(n - (this.touchStart?.y ?? 0)) * this.touchMultiplier; this.touchStart.x = t, this.touchStart.y = n, this.lastDelta = { x: r, y: i }, this.emitter.emit(`scroll`, { deltaX: r, deltaY: i, event: e }) }, this.onTouchEnd = e => { this.emitter.emit(`scroll`, { deltaX: this.lastDelta.x, deltaY: this.lastDelta.y, event: e }) }, this.onWheel = e => { let { deltaX: t, deltaY: n, deltaMode: r } = e; t *= r === 1 ? Q : r === 2 ? this.windowWidth : 1, n *= r === 1 ? Q : r === 2 ? this.windowHeight : 1, t *= this.wheelMultiplier, n *= this.wheelMultiplier, this.emitter.emit(`scroll`, { deltaX: t, deltaY: n, event: e }) }, this.onWindowResize = () => { this.windowWidth = v.innerWidth, this.windowHeight = v.innerHeight }, this.element = e, this.wheelMultiplier = t, this.touchMultiplier = n, this.touchStart = { x: null, y: null }, this.emitter = new ot, v.addEventListener(`resize`, this.onWindowResize, !1), this.onWindowResize(), this.element.addEventListener(`wheel`, this.onWheel, { passive: !1 }), this.element.addEventListener(`touchstart`, this.onTouchStart, { passive: !1 }), this.element.addEventListener(`touchmove`, this.onTouchMove, { passive: !1 }), this.element.addEventListener(`touchend`, this.onTouchEnd, { passive: !1 }) } on(e, t) { return this.emitter.on(e, t) } destroy() { this.emitter.destroy(), v.removeEventListener(`resize`, this.onWindowResize, !1), this.element.removeEventListener(`wheel`, this.onWheel), this.element.removeEventListener(`touchstart`, this.onTouchStart), this.element.removeEventListener(`touchmove`, this.onTouchMove), this.element.removeEventListener(`touchend`, this.onTouchEnd) } }, ct = class { constructor({ wrapper: e = v, content: t = document.documentElement, wheelEventsTarget: n = e, eventsTarget: r = n, smoothWheel: i = !0, syncTouch: a = !1, syncTouchLerp: o = .075, touchInertiaMultiplier: s = 35, duration: c, easing: l = (e => Math.min(1, 1.001 - 2 ** (-10 * e))), lerp: u = .1, infinite: d = !1, orientation: f = `vertical`, gestureOrientation: p = `vertical`, touchMultiplier: m = 1, wheelMultiplier: h = 1, autoResize: g = !0, prevent: _, virtualScroll: y, __experimental__naiveDimensions: b = !1 } = {}) { this.__isScrolling = !1, this.__isStopped = !1, this.__isLocked = !1, this.userData = {}, this.lastVelocity = 0, this.velocity = 0, this.direction = 0, this.onPointerDown = e => { e.button === 1 && this.reset() }, this.onVirtualScroll = e => { if (typeof this.options.virtualScroll == `function` && !1 === this.options.virtualScroll(e)) return; let { deltaX: t, deltaY: n, event: r } = e; if (this.emitter.emit(`virtual-scroll`, { deltaX: t, deltaY: n, event: r }), r.ctrlKey) return; let i = r.type.includes(`touch`), a = r.type.includes(`wheel`); if (this.isTouching = r.type === `touchstart` || r.type === `touchmove`, this.options.syncTouch && i && r.type === `touchstart` && !this.isStopped && !this.isLocked) return void this.reset(); let o = t === 0 && n === 0, s = this.options.gestureOrientation === `vertical` && n === 0 || this.options.gestureOrientation === `horizontal` && t === 0; if (o || s) return; let c = r.composedPath(); c = c.slice(0, c.indexOf(this.rootElement)); let l = this.options.prevent; if (c.find((e => e instanceof Element && (typeof l == `function` && l?.(e) || e.hasAttribute?.call(e, `data-lenis-prevent`) || i && e.hasAttribute?.call(e, `data-lenis-prevent-touch`) || a && e.hasAttribute?.call(e, `data-lenis-prevent-wheel`) || e.classList?.contains(`lenis`) && !e.classList?.contains(`lenis-stopped`))))) return; if (this.isStopped || this.isLocked) return void r.preventDefault(); if (!(this.options.syncTouch && i || this.options.smoothWheel && a)) return this.isScrolling = `native`, void this.animate.stop(); r.preventDefault(); let u = n; this.options.gestureOrientation === `both` ? u = Math.abs(n) > Math.abs(t) ? n : t : this.options.gestureOrientation === `horizontal` && (u = t); let d = i && this.options.syncTouch, f = i && r.type === `touchend` && Math.abs(u) > 5; f && (u = this.velocity * this.options.touchInertiaMultiplier), this.scrollTo(this.targetScroll + u, Object.assign({ programmatic: !1 }, d ? { lerp: f ? this.options.syncTouchLerp : 1 } : { lerp: this.options.lerp, duration: this.options.duration, easing: this.options.easing })) }, this.onNativeScroll = () => { if (clearTimeout(this.__resetVelocityTimeout), delete this.__resetVelocityTimeout, this.__preventNextNativeScrollEvent) delete this.__preventNextNativeScrollEvent; else if (!1 === this.isScrolling || this.isScrolling === `native`) { let e = this.animatedScroll; this.animatedScroll = this.targetScroll = this.actualScroll, this.lastVelocity = this.velocity, this.velocity = this.animatedScroll - e, this.direction = Math.sign(this.animatedScroll - e), this.isScrolling = `native`, this.emit(), this.velocity !== 0 && (this.__resetVelocityTimeout = setTimeout((() => { this.lastVelocity = this.velocity, this.velocity = 0, this.isScrolling = !1, this.emit() }), 400)) } }, v.lenisVersion = `1.1.9`, e && e !== document.documentElement && e !== document.body || (e = v), this.options = { wrapper: e, content: t, wheelEventsTarget: n, eventsTarget: r, smoothWheel: i, syncTouch: a, syncTouchLerp: o, touchInertiaMultiplier: s, duration: c, easing: l, lerp: u, infinite: d, gestureOrientation: p, orientation: f, touchMultiplier: m, wheelMultiplier: h, autoResize: g, prevent: _, virtualScroll: y, __experimental__naiveDimensions: b }, this.animate = new it, this.emitter = new ot, this.dimensions = new at({ wrapper: e, content: t, autoResize: g }), this.updateClassName(), this.userData = {}, this.time = 0, this.velocity = this.lastVelocity = 0, this.isLocked = !1, this.isStopped = !1, this.isScrolling = !1, this.targetScroll = this.animatedScroll = this.actualScroll, this.options.wrapper.addEventListener(`scroll`, this.onNativeScroll, !1), this.options.wrapper.addEventListener(`pointerdown`, this.onPointerDown, !1), this.virtualScroll = new st(r, { touchMultiplier: m, wheelMultiplier: h }), this.virtualScroll.on(`scroll`, this.onVirtualScroll) } destroy() { this.emitter.destroy(), this.options.wrapper.removeEventListener(`scroll`, this.onNativeScroll, !1), this.options.wrapper.removeEventListener(`pointerdown`, this.onPointerDown, !1), this.virtualScroll.destroy(), this.dimensions.destroy(), this.cleanUpClassName() } on(e, t) { return this.emitter.on(e, t) } off(e, t) { return this.emitter.off(e, t) } setScroll(e) { this.isHorizontal ? this.rootElement.scrollLeft = e : this.rootElement.scrollTop = e } resize() { this.dimensions.resize() } emit() { this.emitter.emit(`scroll`, this) } reset() { this.isLocked = !1, this.isScrolling = !1, this.animatedScroll = this.targetScroll = this.actualScroll, this.lastVelocity = this.velocity = 0, this.animate.stop() } start() { this.isStopped && (this.isStopped = !1, this.reset()) } stop() { this.isStopped || (this.isStopped = !0, this.animate.stop(), this.reset()) } raf(e) { let t = e - (this.time || e); this.time = e, this.animate.advance(.001 * t) } scrollTo(e, { offset: t = 0, immediate: n = !1, lock: r = !1, duration: i = this.options.duration, easing: a = this.options.easing, lerp: o = this.options.lerp, onStart: s, onComplete: c, force: l = !1, programmatic: u = !0, userData: d = {} } = {}) { if (!this.isStopped && !this.isLocked || l) { if (typeof e == `string` && [`top`, `left`, `start`].includes(e)) e = 0; else if (typeof e == `string` && [`bottom`, `right`, `end`].includes(e)) e = this.limit; else { let n; if (typeof e == `string` ? n = document.querySelector(e) : e instanceof HTMLElement && e != null && e.nodeType && (n = e), n) { if (this.options.wrapper !== v) { let e = this.rootElement.getBoundingClientRect(); t -= this.isHorizontal ? e.left : e.top } let r = n.getBoundingClientRect(); e = (this.isHorizontal ? r.left : r.top) + this.animatedScroll } } if (typeof e == `number` && (e += t, e = Math.round(e), this.options.infinite ? u && (this.targetScroll = this.animatedScroll = this.scroll) : e = rt(0, e, this.limit), e !== this.targetScroll)) { if (this.userData = d, n) return this.animatedScroll = this.targetScroll = e, this.setScroll(this.scroll), this.reset(), this.preventNextNativeScrollEvent(), this.emit(), c?.(this), void (this.userData = {}); u || (this.targetScroll = e), this.animate.fromTo(this.animatedScroll, e, { duration: i, easing: a, lerp: o, onStart: () => { r && (this.isLocked = !0), this.isScrolling = `smooth`, s?.(this) }, onUpdate: (e, t) => { this.isScrolling = `smooth`, this.lastVelocity = this.velocity, this.velocity = e - this.animatedScroll, this.direction = Math.sign(this.velocity), this.animatedScroll = e, this.setScroll(this.scroll), u && (this.targetScroll = e), t || this.emit(), t && (this.reset(), this.emit(), c?.(this), this.userData = {}, this.preventNextNativeScrollEvent()) } }) } } } preventNextNativeScrollEvent() { this.__preventNextNativeScrollEvent = !0, requestAnimationFrame((() => { delete this.__preventNextNativeScrollEvent })) } get rootElement() { return this.options.wrapper === v ? document.documentElement : this.options.wrapper } get limit() { return this.options.__experimental__naiveDimensions ? this.isHorizontal ? this.rootElement.scrollWidth - this.rootElement.clientWidth : this.rootElement.scrollHeight - this.rootElement.clientHeight : this.dimensions.limit[this.isHorizontal ? `x` : `y`] } get isHorizontal() { return this.options.orientation === `horizontal` } get actualScroll() { return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop } get scroll() { return this.options.infinite ? function (e, t) { return (e % t + t) % t }(this.animatedScroll, this.limit) : this.animatedScroll } get progress() { return this.limit === 0 ? 1 : this.scroll / this.limit } get isScrolling() { return this.__isScrolling } set isScrolling(e) { this.__isScrolling !== e && (this.__isScrolling = e, this.updateClassName()) } get isStopped() { return this.__isStopped } set isStopped(e) { this.__isStopped !== e && (this.__isStopped = e, this.updateClassName()) } get isLocked() { return this.__isLocked } set isLocked(e) { this.__isLocked !== e && (this.__isLocked = e, this.updateClassName()) } get isSmooth() { return this.isScrolling === `smooth` } get className() { let e = `lenis`; return this.isStopped && (e += ` lenis-stopped`), this.isLocked && (e += ` lenis-locked`), this.isScrolling && (e += ` lenis-scrolling`), this.isScrolling === `smooth` && (e += ` lenis-smooth`), e } updateClassName() { this.cleanUpClassName(), this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim() } cleanUpClassName() { this.rootElement.className = this.rootElement.className.replace(/lenis(-\w+)?/g, ``).trim() } } })); function ut(e) { let { intensity: t } = e, n = a(null); return i(() => { if (n.current) try { n.current.scrollTo(0, { immediate: !0 }) } catch (e) { console.error(`Error scrolling to top:`, e) } }, [n]), i(() => { let e = () => { try { let e = document.querySelector(`[data-frameruni-stop-scroll]`), t = document.documentElement, r = t && t.style && t.style.overflow === `hidden`; n.current && (e || r ? n.current.stop() : n.current.start()) } catch (e) { console.error(`Error in checkForStopScroll:`, e) } }; e(); let t, r; try { t = new MutationObserver(e), r = new MutationObserver(e), document && document.documentElement && (t.observe(document.documentElement, { childList: !0, subtree: !0, attributes: !0, attributeFilter: [`data-frameruni-stop-scroll`] }), r.observe(document.documentElement, { attributes: !0, attributeFilter: [`style`] })) } catch (e) { console.error(`Error setting up observers:`, e) } return () => { try { t && t.disconnect(), r && r.disconnect() } catch (e) { console.error(`Error disconnecting observers:`, e) } } }, []), i(() => { try { if (!document) return; let e = document.getElementsByTagName(`*`); for (let t = 0; t < e.length; t++) { let n = e[t]; if (n) try { let e = v.getComputedStyle(n); e && e.getPropertyValue(`overflow`) === `auto` && n.setAttribute(`data-lenis-prevent`, `true`) } catch (e) { console.error(`Error getting computed style:`, e) } } } catch (e) { console.error(`Error in overflow detection:`, e) } }, []), i(() => { try { if (typeof ct != `function`) { console.error(`Lenis is not available`); return } n.current = new ct({ duration: (t || 10) / 10 }); let e = t => { if (n.current) try { n.current.raf(t), requestAnimationFrame(e) } catch (e) { console.error(`Error in animation frame:`, e) } }, r = requestAnimationFrame(e); return () => { if (cancelAnimationFrame(r), n.current) try { n.current.destroy(), n.current = null } catch (e) { console.error(`Error destroying Lenis:`, e) } } } catch (e) { return console.error(`Error initializing Lenis:`, e), () => { } } }, [t]), i(() => { try { if (!document || !n.current) return; let e = Array.from(document.querySelectorAll(`a[href]`) || []).filter(e => { if (!e) return !1; let t = e; if (!t.href) return !1; let n = t.href.startsWith(v.location.origin) || t.href.startsWith(`./`) || t.href.startsWith(`/`), r = t.href.includes(`#`); return n && r }).map(e => { try { let t = e, n = t.href.includes(`#`) ? `#${t.href.split(`#`).pop()}` : ``, r = n ? decodeURIComponent(n) : ``, i = 0; try { if (r) { let e = document.querySelector(r); if (e) { let t = v.getComputedStyle(e).scrollMarginTop; i = t && parseInt(t) || 0 } } } catch (e) { console.error(`Error finding target element:`, e) } return { href: n, scrollMargin: i, anchorElement: t } } catch (e) { return console.error(`Error processing anchor:`, e), null } }).filter(Boolean), t = (e, t, r) => { try { e && e.preventDefault && e.preventDefault(), n.current && t && n.current.scrollTo(t, { offset: -(r || 0) }) } catch (e) { console.error(`Error in anchor click handler:`, e) } }, r = e.map(({ href: e, scrollMargin: n }) => r => t(r, e, n)); return e.forEach(({ anchorElement: e }, t) => { e && r[t] && e.addEventListener(`click`, r[t]) }), () => { e.forEach(({ anchorElement: e }, t) => { e && r[t] && e.removeEventListener(`click`, r[t]) }) } } catch (e) { return console.error(`Error setting up anchor links:`, e), () => { } } }, [n]), h(`div`, { style: e.style }) } var dt, ft, pt = e((() => { n(), l(), O(), lt(), _(), dt = k(ut, [`html.lenis { height: auto; }`, `.lenis.lenis-smooth { scroll-behavior: auto !important; }`, `.lenis.lenis-smooth [data-lenis-prevent] { overscroll-behavior: contain; }`, `.lenis.lenis-stopped { overflow: hidden; }`, `.lenis.lenis-scrolling iframe { pointer-events: none; }`], ``), ft = dt, dt.displayName = `Smooth Scroll`, D(dt, { intensity: { title: `Intensity`, type: A.Number, defaultValue: 10, min: 0, description: `More components at [Framer University](https://frameruni.link/cc).` } }) })); export { q as a, ke as c, nt as i, pt as n, Ze as o, $e as r, B as s, ft as t };
//# sourceMappingURL=SmoothScroll_Prod.ChnthBlu.mjs.map